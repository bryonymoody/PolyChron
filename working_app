#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Mar  9 12:35:28 2020

@author: bryony
"""
import tkinter as tk
from tkinter import ttk
import tabulate
import copy
from tabulate import tabulate
import sys
import re
import ast
import time
import threading
from PIL import Image, ImageTk, ImageChops
from networkx.drawing.nx_pydot import read_dot, write_dot
import networkx as nx
import pydot
import numpy as np
import pandas as pd
from tkinter.filedialog import askopenfile
from graphviz import render
#from networkx.readwrite import json_graph

phase_true = 0
    
def trim(im_trim):
    t0 = time.time()
    """Trims images down"""
    bg_trim = Image.new(im_trim.mode, im_trim.size)
    diff = ImageChops.difference(im_trim, bg_trim)
#    print(im_trim.size, im_trim.mode)
    diff = ImageChops.add(diff, diff, 2.0, -100)
 #   print(diff)
    bbox = diff.getbbox()
    
 #   print("trim", str(time.time() - t0))
    return im_trim.crop(bbox)

def polygonfunc(i):
    x = re.findall(r'points="(.*?)"', i)[0].replace(' ', ',')
    a = x.split(",")
    coords_converted = [float(a[2]), float(a[6]), -1*float(a[7]), -1*float(a[3])]
    return(coords_converted)

def ellipsefunc(i):
    x = re.findall(r'cx=(.*?)/>', i)[0].replace(' ', ',')
    x = x.replace('cy=', '').replace('rx=', '').replace('ry=','').replace('"', '')
    a = x.split(",")
    coords_converted = [float(a[0]) - float(a[2]), float(a[0]) + float(a[2]), -1*float(a[1]) - float(a[3]), -1*float(a[1]) + float(a[3])]
    return(coords_converted)


def node_coords_fromjson(graph):
    t0 = time.time()
    """Gets coordinates of each node"""
    graphs = nx.nx_pydot.to_pydot(graph)    
    svg_string = str(graphs.create_svg())
    scale_info = re.search('points=(.*?)/>', svg_string).group(1).replace(' ', ',')
    scale_info = scale_info.split(",")
    scale = [float(scale_info[4]), -1*float(scale_info[3])]
    coords_x = re.findall(r'id="node(.*?)</text>', svg_string)      
    coords_temp = [polygonfunc(i) if "points" in i else ellipsefunc(i) for i in coords_x]
    node_test = re.findall(r'node">\\n<title>(.*?)</title>', svg_string)
    node_list = [i.replace('&#45;', '-') for i in node_test]
    new_pos = dict(zip(node_list, coords_temp))
    df = pd.DataFrame.from_dict(new_pos, orient='index', columns=['x_lower', 'x_upper', 'y_lower', 'y_upper'])
    print((sys._getframe().f_code.co_name), str(time.time() - t0))
    return df, scale

def all_node_info(node_list, x_image, node_info):
    t0 = time.time()
    """obtains node attributes from original dot file"""
    for i in node_list:
        for j in x_image:
            b_string = re.search("\"(.*)\" ", j)
            if b_string is not None:
                if i == b_string.group(1):
                    if i in j and '->' not in j:
                        tset = j[(j.index('[')+1):(len(j)-1)]
                        atr_new = tset.replace('] [', '\',\'')
                        atr_new = atr_new.replace('=', '\':\' ')
                        atr_new = atr_new.replace('\' \"', '\"')
                        atr_new = atr_new.replace('\"\'', '\"')
                        atr_new = atr_new.replace('\' ', '\'')
                        atr_newer = str('{\''+atr_new+'}')
                        dicc = ast.literal_eval(atr_newer)
                        node_info.append(dicc)
#    print((sys._getframe().f_code.co_name), str(time.time() - t0))  
    return node_info

def imagefunc(dotfile):
    t0 = time.time()
    """Sets note attributes to a dot string"""
    file = read_dot(dotfile)
 ####code to get colours####
    f_string = open(str(dotfile), "r")
    dotstr = f_string.read()
    dotstr = dotstr.replace(";<", "@<")
    dotstr = dotstr.replace("14.0", "50.0")
#change any ';>' to '@>' then back again after
    x_image = dotstr.rsplit(";")
    for i in enumerate(x_image):
        x_image[i[0]] = x_image[i[0]].replace("@<", ";<")
    node_list = list(file.nodes)
    node_info_init = list()
    node_info = all_node_info(node_list, x_image, node_info_init)
    for k in enumerate(node_list):
        node_info[k[0]].update({"Date":"None", "Find_Type":"None", "Phase":node_info[k[0]]['fillcolor']})
    individ_attrs = zip(node_list, node_info)
    attrs = dict(individ_attrs)#add the dictionary of attributed to a node
    nx.set_node_attributes(file, attrs)
 #   print((sys._getframe().f_code.co_name), str(time.time() - t0))
    return file

def chrono_edge_remov(file_graph):
    xs, ys = [], []
    for x, y in list(file_graph.edges):
        xs.append(x)
        ys.append(y)
    graph_data = phase_info_func(file_graph)
    x_l, y_l = graph_data[2][0], graph_data[2][1]        
    evenlist, oddlist, elist, olist = [], [], [], []
    for i in range(len(x_l)): 
      if (i % 2 == 0): 
         evenlist.append(x_l[i])
         elist.append(y_l[i]) 
      else: 
         oddlist.append(x_l[i])
         olist.append(y_l[i])
         
    for j in range(len(evenlist)):     
         file_graph.remove_edge(oddlist[j], evenlist[j])     
    #add boundary nodes
    #add dges between nodes using y_l as reference
    #figure out top and bottom nodes
    #figure out floating nodes

    phase_list = graph_data[1][2]
  #  phase_nodes = []
    for node in list(phase_list):
        alp_beta_node_add(node, file_graph)
        
    #for i, j in enumerate(elist):
    #    file_graph.add_edge("a_" + str(j), evenlist[i])


        
    for i, j in enumerate(elist):
        file_graph.add_edge("b_" + str(j), evenlist[i], arrows=False)    
    for i, j in enumerate(olist):
        file_graph.add_edge(oddlist[i], "a_" + str(j.replace("_below", "")), arrows=False)
    return graph_data, [xs, ys]



def chrono_edge_add(file_graph, graph_data, xs_ys, phasedict, phase_trck):
    xs = xs_ys[0]
    ys = xs_ys[1]
    #phase_norm = [phase[ph][phase[ph].rfind("/")+1:len(phase[ph])] for ph in phase]
    phase_norm, node_list = graph_data[1][0], graph_data[1][1]
    all_node_phase = dict(zip(node_list, phase_norm))     
    for i in node_list:
        if (i in xs) == False:
            if (i in ys) == False:
                file_graph.add_edge("b_" + str(all_node_phase[i]), i, arrows=False)
                file_graph.add_edge(i, "a_" + str(all_node_phase[i]), arrows=False)
            else:
                file_graph.add_edge(i, "a_" + str(all_node_phase[i]), arrows=False)
        elif (i in xs) == True:
            if (i in ys) == False:
                #print(i)
                file_graph.add_edge("b_" + str(all_node_phase[i]), i, arrows=False)
    
    for p in list(set(phase_trck)):
        relation = phasedict[p]
        if relation == 'gap':
            file_graph.add_edge("a_" + str(p[0]), "b_" + str(p[1]))
        if relation == 'overlap':
            file_graph.add_edge("b_" + str(p[1]), "a_" + str(p[0]))
        if relation == "abuting":
            x_bef = list(file_graph)
            print("x_bef ", x_bef)
            file_graph = nx.contracted_nodes(file_graph, "a_" + str(p[0]), "b_" + str(p[1]))
            x_nod = list(file_graph) 
            print("x_nod ", x_nod)
            newnode = str("a_" + str(p[0]) + " = " +"b_" + str(p[1]))
            y_nod = [newnode if i=="a_" + str(p[0]) else i for i in x_nod]
            print("y_nod ", y_nod)
            mapping = dict(zip(x_nod, y_nod))
            file_graph = nx.relabel_nodes(file_graph, mapping)
    #print(phase_trck)
    graph = nx.DiGraph()
    graph.add_edges_from(phase_trck)
 #   print(phase_trck)
   # imgrender(graph)
    graph_temp = nx.transitive_reduction(graph)    
    a = set(graph.edges())
    b = set(graph_temp.edges())
    if len(list(a-b)) != 0:
        rem = list(a-b)[0]
        file_graph.remove_edge(rem[0], rem[1])
    return(file_graph)



def imgrender(file):
    t0 = time.time()
    """renders png from dotfile"""
    write_dot(file, 'fi_new')
    render('dot', 'png', 'fi_new')
    inp = Image.open("fi_new.png")
    inp = trim(inp)
    inp.save("testdag.png")
    outp = Image.open("testdag.png")
    print((sys._getframe().f_code.co_name), str(time.time() - t0))
    return outp



def imgrender2(file):
    t0 = time.time()
    """renders png from dotfile"""
    write_dot(file, 'fi_new_chrono')
    render('dot', 'png', 'fi_new_chrono')
    inp = Image.open("fi_new_chrono.png")
    inp = trim(inp)
    inp.save("testdag_chrono.png")
    outp = Image.open("testdag_chrono.png")
    print((sys._getframe().f_code.co_name), str(time.time() - t0))
    return outp


def edge_of_phase(test1, pset, node_list, node_info):
    t0 = time.time()
    """find nodes on edge of each phase"""
    x_l = []
    y_l = []
    mydict = {}
    phase_tracker = []
    for i in enumerate(pset):
        temp_nodes_list = []
        for j in enumerate(node_list):
            if node_info[j[0]]["fillcolor"] == pset[i[0]]:
                temp_nodes_list.append(node_list[j[0]])
                p_phase = "Phase " + str(pset[i[0]][pset[i[0]].rfind("/")+1:len(pset[i[0]])])
                node_info[j[0]].update({"Phase":p_phase})
                mydict[str(pset[i[0]][pset[i[0]].rfind("/")+1:len(pset[i[0]])])] = temp_nodes_list
    for i in enumerate(test1):
        for key in mydict:
            if test1[i[0]][1] in mydict[key] and test1[i[0]][0] not in mydict[key]:
                x_l.append(test1[i[0]][1])
                y_l.append(key)
                phase_lst = [list(mydict.values()).index(j) for j in list(mydict.values()) if
                             test1[i[0]][0] in j]
                key_1 = (list(mydict.keys())[phase_lst[0]]) #trying to find phase of other value
                x_l.append(test1[i[0]][0])
                y_l.append(str(key_1 + "_below"))
                phase_tracker.append((key_1, key))
#    print((sys._getframe().f_code.co_name), str(time.time() - t0))
    return x_l, y_l, mydict.keys(), phase_tracker

#def phase_info_func(file_graph):
#    t0 = time.time()
#    """returns a dictionary of phases and nodes in each phase"""
#    phase = nx.get_node_attributes(file_graph, "fillcolor")
# ####code to get colours####
#    f_str = open(str(FILE_INPUT), "r")
#    dotstr = f_str.read()
#    dotstr = dotstr.replace(";<", "@<")
#    dotstr = dotstr.replace("14.0", "50.0")
##change any ';>' to '@>' then back again after
#    x_phaseinf = dotstr.rsplit(";")
#    for i in enumerate(x_phaseinf):
#        x_phaseinf[i[0]] = x_phaseinf[i[0]].replace("@<", ";<")
#    node_list = list(file_graph.nodes)
#    node_info = all_node_info(node_list, x_phaseinf, list())
#    res = []
#    for key in phase.keys():
#        res.append(phase[key])
#    x_l, y_l = edge_of_phase(list(nx.line_graph(file_graph)), list(set(res)), node_list, node_info)
#    testdic = dict(zip(x_l, y_l))
#    reversed_dict = {}
#    for key, value in testdic.items():
#        reversed_dict.setdefault(value, [])
#        reversed_dict[value].append(key)
#  #  print((sys._getframe().f_code.co_name), str(time.time() - t0))    
#    return reversed_dict

def phase_info_func(file_graph):
    t0 = time.time()
    """returns a dictionary of phases and nodes in each phase"""
    phase = nx.get_node_attributes(file_graph, "fillcolor")
    phase_norm = [phase[ph][phase[ph].rfind("/")+1:len(phase[ph])] for ph in phase]
# ####code to get colours####
    f_str = open(str(FILE_INPUT), "r")
    dotstr = f_str.read()
    dotstr = dotstr.replace(";<", "@<")
    dotstr = dotstr.replace("14.0", "50.0")
##change any ';>' to '@>' then back again after
    x_phaseinf = dotstr.rsplit(";")
    for i in enumerate(x_phaseinf):
        x_phaseinf[i[0]] = x_phaseinf[i[0]].replace("@<", ";<")
    node_list = list(file_graph.nodes)
    node_info = all_node_info(node_list, x_phaseinf, list())
    res = []
    for key in phase.keys():
        res.append(phase[key])
    x_l, y_l, phase_list, phase_trck = edge_of_phase(list(nx.line_graph(file_graph)), list(set(res)), node_list, node_info)
    testdic = dict(zip(x_l, y_l))
    reversed_dict = {}
    for key, value in testdic.items():
        reversed_dict.setdefault(value, [])
        reversed_dict[value].append(key)
        
  #  print((sys._getframe().f_code.co_name), str(time.time() - t0))    
    return reversed_dict, [phase_norm, node_list, phase_list, phase_trck], [x_l, y_l]

def alp_beta_node_add(x, graph):
    graph.add_node("a_" + str(x), shape="diamond", fontsize="20.0",
                                   fontname="Arial", penwidth="1.0")
    graph.add_node("b_" + str(x), shape="diamond", fontsize="20.0",
                                   fontname="Arial", penwidth="1.0")
  #  return(["a_" + str(x), "b_" + str(x)])


def rank_func(tes, file_content):
    t0 = time.time()
    """adds strings into dot string to make nodes of the same phase the same rank"""
    rank_same = []
    for key in tes.keys():
        x_rank = tes[key]
        y_1 = str(x_rank)
        y_2 = y_1.replace("[", "")
        y_3 = y_2.replace("]", "")
        y_4 = y_3.replace("'", "")
        y_5 = y_4.replace(",", ";")
        x_2 = "{rank = same; "+y_5+";}\n"
        rank_same.append(x_2)
    rank_string = ''.join(rank_same)[:-1]
    new_string = file_content[:-2] + rank_string + file_content[-2]
 #   print((sys._getframe().f_code.co_name), str(time.time() - t0))
    return new_string

def imgrender_phase(file):
    t0 = time.time()
    """Renders image from dot file with all nodes of the same phase collected together"""
    write_dot(file, 'fi_new.txt')
    my_file = open("fi_new.txt")
    file_content = my_file.read()
    new_string = rank_func(phase_info_func(file)[0], file_content)
    textfile = open('fi_new.txt', 'w')
    textfile.write(new_string)
    textfile.close()
    (graph,) = pydot.graph_from_dot_file('fi_new.txt')
    graph.write_png('test.png')
    inp = Image.open("test.png")
    inp = trim(inp)
    inp.save("testdag.png")
    outp = Image.open("testdag.png")
  #  print((sys._getframe().f_code.co_name), str(time.time() - t0))
    return outp
def test_print():
    print("testing threading")

# This is to prevent infinite right click menus; it sees if there is an existing menu
# and removes it, bringing it out in a new position.


class popupWindow(object):
    def __init__(self,master):
        top=self.top=tk.Toplevel(master)
        self.l=tk.Label(top,text="Context Number")
        self.l.pack()
        self.e=tk.Entry(top)
        self.e.pack()
        self.b=tk.Button(top,text='Ok',command=self.cleanup)
        self.b.pack()
    def cleanup(self):
        self.value=self.e.get()
        self.top.destroy()
        
class popupWindow(object):
    def __init__(self,master):
        top=self.top=tk.Toplevel(master)
        self.l=tk.Label(top,text="Phase")
        self.l.pack()
        self.e=tk.Entry(top)
        self.e.pack()
        self.b=tk.Button(top,text='Ok',command=self.cleanup)
        self.b.pack()
    def cleanup(self):
        self.value=self.e.get()
        self.top.destroy()
        
        
class popupWindow2(object):
    def __init__(self,master, graph, canvas):
        top=tk.Toplevel(master)
        top.geometry("300x300")
        self.graph = graph
        self.metacanvas = canvas
        self.canvas2 = tk.Canvas(top, bg="white")
        self.canvas2.place(relx=0, rely=0, relwidth=1, relheight=1)
        #canvas to hold the metadata

#        #making node add section
#        #entry box for adding metadata
        self.entry3 = tk.Entry(self.canvas2)
        self.button3 = tk.Button(top, text='Add Metadata to node', bg="#b3dcf2",
                                 font=("Arial", 14), command=lambda:self.testcom())#need to add command
  #      self.button4 = tk.Button(text='Phasing', bg="#b3dcf2",
  #                               font=("Arial", 12), command=self.phasing)
        self.label3 = tk.Label(self.canvas2, text='Node', bg='white', font=("Arial", 14))
        self.canvas2.create_window(40, 60, window=self.entry3, width=50)
        self.canvas2.create_window(40, 35, window=self.label3)
   #     self.canvas2.create_window(140, 100, window=self.button3)
  #      self.canvas2.create_window(300, 100, window=self.button4)
        self.dict = {'Find_Type': ['Find1', 'Find2', 'Find3'],
                     'Date': ['None', 'Input date'],
                     'Phase': ['None', 'Input phase']}
#               
        self.variable_a = tk.StringVar(top)
        self.variable_b = tk.StringVar(top)
        self.variable_c = tk.StringVar(top)
        self.variable_d = tk.StringVar(top)
        self.variable_a.trace('w', self.update_options)
        self.variable_b.trace('w', self.testdate_input)
        self.variable_c.trace('w', self.update_options)
        self.variable_d.trace('w', self.update_options)
        self.optionmenu_a = tk.OptionMenu(top, self.variable_a, *self.dict.keys())
        self.optionmenu_b = tk.OptionMenu(top, self.variable_b, 'None')
        self.variable_a.set('Date')
        self.optionmenu_a.place(relx=0.3, rely=0.15)
        self.optionmenu_b.place(relx=0.6, rely=0.15)    
  #      self.b=tk.Button(top,text='Ok',command=self.cleanup)
        self.button3.place(relx = 0.1, rely = 0.7)
        
  #      self.b=tk.Button(top,text='Ok',command=self.cleanup)
    #    self.button3.place(relx = 0.1, rely = 0.7)
    def testdate_input(self, *args):
        print("test1")
        if self.variable_b.get() == "Input date":
           # print(type(self.label6))
#            self.label6.destroy()
#            self.entry6.destroy()            
            self.label4 = tk.Label(self.canvas2, text='Radiocarbon Date', bg='white', font=("Arial", 14))
            self.entry4 = tk.Entry(self.canvas2)
            self.canvas2.create_window(90, 130, window=self.entry4, width=50)
            self.canvas2.create_window(90, 90, window=self.label4)
            self.label5 = tk.Label(self.canvas2, text='Error', bg='white', font=("Arial", 14))
            self.entry5 = tk.Entry(self.canvas2)
            self.canvas2.create_window(200, 130, window=self.entry5, width=50)
            self.canvas2.create_window(200, 90, window=self.label5)
        if self.variable_b.get() == "Input phase":          
            self.label6 = tk.Label(self.canvas2, text='Phase', bg='white', font=("Arial", 14))
            self.entry6 = tk.Entry(self.canvas2)
            self.canvas2.create_window(90, 130, window=self.entry6, width=50)
            self.canvas2.create_window(90, 90, window=self.label6)
     
        
    def testcom(self):
        t0 = time.time()
        """metadata menu 2 update"""
        if self.variable_a.get() == "Phase":  
            if self.variable_b.get() == "Input phase":
                self.graph.nodes()[str(self.entry3.get())].update({"Phase":self.entry6.get()})
                self.label6.destroy()
                self.entry6.destroy()
            else:
                self.graph.nodes()[str(self.entry3.get())].update({"Phase":self.variable_b.get()})
        elif self.variable_a.get() == "Date":
            if self.variable_b.get() == "Input date":
                self.graph.nodes()[str(self.entry3.get())].update({"Date": [self.entry4.get(), self.entry5.get()]})
                self.label4.destroy()
                self.entry4.destroy()
                self.label5.destroy()
                self.entry5.destroy()  
            else:
                self.graph.nodes()[str(self.entry3.get())].update({"Date":self.variable_b.get()})
        elif self.variable_a.get() == "Find_Type":
            self.graph.nodes()[str(self.entry3.get())].update({"Find_Type":self.variable_b.get()})
        self.metatext = tk.Text(self.metacanvas, font=("Arial", 14), width=120, height=40)
        self.metacanvas.create_window((0, 0), window=self.metatext, anchor='nw')
        self.meta1 = pd.DataFrame.from_dict(self.graph.nodes()[str(self.entry3.get())],
                                            orient='index')
        self.meta2 = self.meta1.loc["Date":"Phase",]
        self.meta2.columns = ["Data"]
        #if self.meta2.loc["Date"] != "None":
        if self.meta2.loc["Date"][0] != "None":
           self.meta2.loc["Date"][0] = str(self.meta2.loc["Date"][0][0]) + " +- " + str(self.meta2.loc["Date"][0][1]) + " Carbon BP"
       # self.nice_meta2 = tabulate(self.meta2, headers='keys', tablefmt='psql')
        self.metatext.insert('end', 'Metadata of node ' +
                             str(self.entry3.get()) + ':\n')
        cols = list(self.meta2.columns)
        tree = ttk.Treeview(self.metacanvas)
        tree["columns"] = cols
        tree.place(relx=0, rely=0.25)
        tree.column("Data", anchor="w")
        tree.heading("Data", text="Data", anchor='w')        
        for index, row in self.meta2.iterrows():
            tree.insert("",0,text=index,values=list(row))


        self.metatext.configure(state='disabled')
  #      print((sys._getframe().f_code.co_name), str(time.time() - t0))
    def update_options(self, *args):
    #    global pos_dag
        t0 = time.time()
        """updates metadata drop down menu 1"""
        meta_data = self.dict[self.variable_a.get()]
        self.variable_b.set(meta_data[0])
        menu = self.optionmenu_b['menu']
        menu.delete(0, 'end')
        for meta in meta_data:
            menu.add_command(label=meta,
                             command=lambda nation=meta: self.variable_b.set(nation))   
#        print((sys._getframe().f_code.co_name), str(time.time() - t0))

                
    def cleanup(self):
        self.value=self.canvas2.get()
        self.top.destroy()
        
        
class popupWindow3(object):
    def __init__(self, master, graph, canvas):
        self.littlecanvas2 = canvas
        self.top=tk.Toplevel(master)
        self.top.geometry("1000x400")
        self.variable_1 = tk.StringVar(self.top)
        self.variable_2 = tk.StringVar(self.top)
        self.button_a = tk.Button(self.top, text='Add Phase Relationship', bg="#b3dcf2",
                                 font=("Arial", 14), command=lambda:self.phase_rel_func())
        
        self.button_b = tk.Button(self.top, text='Render Chronological graph', bg="#b3dcf2",
                         font=("Arial", 14), command=lambda:self.full_chronograph_func())         
  #      self.variable_1.trace('w', self.update_options1)
       # self.variable_2.trace('w')
        self.graph = graph
        self.graphcopy = copy.deepcopy(self.graph)
        self.step_1 = chrono_edge_remov(self.graphcopy)
        graphedges = self.step_1[0][1][3]
        #print(graphedges)        
        graph = nx.DiGraph()
        graph.add_edges_from(graphedges)
        graph_new = nx.transitive_reduction(graph)
        self.phases = list(graph_new.edges())
        self.menu_list1 = []
        self.menudict = {}
        self.menu_list2 = ["abuting", "gap", "overlap"]
      #  self.dict = {}
        for i in self.phases:
            self.menu_list1.append("Relationship between start of phase " + str(i[0]) + " and end of phase " + str(i[1]))    
        #    self.menu_track.append([str(i[0]), str(i[1])])
        #menu_list2 = ["abuting", "gap", "overlap"]

      #  self.dict = dict(menu_list1)
      #  print(self.dict)        
        self.optionmenu_a = tk.OptionMenu(self.top, self.variable_1, *self.menu_list1)
        self.optionmenu_b = tk.OptionMenu(self.top, self.variable_2, *self.menu_list2)
        #self.variable_a.set('Date')
        self.optionmenu_a.place(relx=0.1, rely=0.15)
        self.optionmenu_b.place(relx=0.6, rely=0.15)
        self.button_a.place(relx=0.7, rely=0.15)
        self.button_b.place(relx=0.4, rely=0.55)
       # print(step_1[0], step_1[1])
   #     chrono_edge_add(self.graphcopy, step_1[0], step_1[1])
        

    def phase_rel_func(self):
        n = re.search('start of phase (.+?) and end', self.variable_1.get()).group(1)
        m = re.search('and end of phase (.+?)', self.variable_1.get()).group(1)
        self.menudict[(n, m)] = self.variable_2.get()
        print(self.variable_2.get())
        self.menu_list1.remove(self.variable_1.get())
     #   self.optionmenu_a = tk.OptionMenu(self.top, self.variable_1, *self.menu_list1)
        self.optionmenu_a['menu'].delete(self.variable_1.get())
       # print(self.menu_list1[0])
        if len(self.menu_list1) > 0:
            self.variable_1.set(self.menu_list1[0])
        else:
            self.variable_1.set("No Phases Left")
        print(self.menudict)
        
    def full_chronograph_func(self):
        self.graphcopy = chrono_edge_add(self.graphcopy, self.step_1[0], self.step_1[1], self.menudict, self.phases)
        print(list(self.graphcopy))
        self.image2 = imgrender2(self.graphcopy)
        self.littlecanvas2.img = ImageTk.PhotoImage(self.image2)
        self.littlecanvas2_img = self.littlecanvas2.create_image(0, 0, anchor="nw",
                                                               image=self.littlecanvas2.img)
#
        self.width2, self.height2 = self.image2.size
        self.imscale2 = 1.0  # scale for the canvaas image
        self.delta2 = 1.1  # zoom magnitude
        # Put image into container rectangle and use it to set proper coordinates to the image
        self.container2 = self.littlecanvas2.create_rectangle(0, 0, self.width2, self.height2, width=0)
        self.littlecanvas2.bind("<Configure>", self.resize2)   
#    def update_options1(self, *args):
#    #    global pos_dag
#        t0 = time.time()
#        """updates metadata drop down menu 1"""
#        meta_data = self.dict[self.variable_1.get()]
#     #   self.variable_1.set(meta_data[0])
#        menu = self.optionmenu_b['menu']
#        menu.delete(0, 'end')
#        for meta in meta_data:
#            menu.add_command(label=meta,
#                             command=lambda nation=meta: self.variable_2.set(nation)) 
            
class MainFrame(tk.Tk):
    """ Main frame for tkinter app"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        #define all variables that are used
        self.h_1 = 0
        self.w_1 = 0
        self.transx = 0
        self.transy = 0
        self.meta1 = ""
        self.metatext = ""
        self.rad_sel = ""
        self.mode = ""
        ##### intial values for all the functions
        self.delnodes = []
        self.edge_nodes = []
        self.comb_nodes = []
        self.edges_del = []
        self.temp = []
        self.x_1 = 1
        self.image = "noimage"
        #forming and placing canvas and little canvas
        self.canvas = tk.Canvas(self, bg="#b3dcf2", bd=0, highlightthickness=0)
        self.canvas.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.canvas.update()
        self.littlecanvas = tk.Canvas(self.canvas, bg='white', bd=0,
                                      selectborderwidth=0, highlightthickness=0, insertwidth=0)
        self.littlecanvas.place(relx=0.02, rely=0.05, relwidth=0.35, relheight=0.9)
        self.littlecanvas2 = tk.Canvas(self.canvas, bg='white', bd=0,
                                      selectborderwidth=0, highlightthickness=0, insertwidth=0)
        self.littlecanvas2.place(relx=0.39, rely=0.05, relwidth=0.35, relheight=0.9)        
        self.littlecanvas.bind("<MouseWheel>", self.wheel)
        self.littlecanvas.bind('<Button-4>', self.wheel)# only with Linux, wheel scroll down
        self.littlecanvas.bind('<Button-5>', self.wheel)
        self.littlecanvas.bind('<Button-1>', self.move_from)
        self.littlecanvas.bind('<B1-Motion>', self.move_to)
        
        self.littlecanvas2.bind("<MouseWheel>", self.wheel2)
        self.littlecanvas2.bind('<Button-4>', self.wheel2)# only with Linux, wheel scroll down
        self.littlecanvas2.bind('<Button-5>', self.wheel2)
        self.littlecanvas2.bind('<Button-1>', self.move_from)
        self.littlecanvas2.bind('<B1-Motion>', self.move_to)
#        self.width2, self.height2 = self.image2.size
#        self.imscale2 = 1.0  # scale for the canvaas image
#        self.delta2 = 1.1  # zoom magnitude
#        # Put image into container rectangle and use it to set proper coordinates to the image
#        self.container2 = self.littlecanvas2.create_rectangle(0, 0, self.width2, self.height2, width=0)
#        self.littlecanvas2.bind("<Configure>", self.resize2)  
    #    self.show_image.after(0, print("test"))
        #placing image on littlecanvas from graph
        self.littlecanvas.rowconfigure(0, weight=1)
        self.littlecanvas.columnconfigure(0, weight=1)
        self.littlecanvas.update()
        #### bind comands to canvas and little canvas ######
        self.dotbutton = tk.Button(self.canvas, text ='Open dot file',  font=("Arial", 14),  command = lambda:open_file1())
        self.dotbutton.place(relx=0.05, rely=0.01, relwidth=0.1, relheight=0.03)
        self.stratbutton = tk.Button(self.canvas, text ='Open strat text file', command = lambda:open_file2())
        self.stratbutton.place(relx=0.17, rely=0.01, relwidth=0.1, relheight=0.03)
        self.datebutton = tk.Button(self.canvas, text ='Open date file', command = lambda:open_file3())
        self.datebutton.place(relx=0.29, rely=0.01, relwidth=0.1, relheight=0.03)
        self.phasebutton = tk.Button(self.canvas, text ='Open phase file', command = lambda:open_file4())
        self.phasebutton.place(relx=0.41, rely=0.01, relwidth=0.1, relheight=0.03)
         

        #########deleted nodes##################
        self.nodescanvas = tk.Canvas(self.canvas, bg='white', bd=0, highlightthickness=0)
        self.nodescanvas.place(relx=0.75, rely=0.05, relwidth=0.35, relheight=0.2)
        self.text = tk.Text(self.nodescanvas, font=("Arial", 14), width=120, height=40)
        self.nodescanvas.create_window((0, 0), window=self.text, anchor='nw')
        self.text.insert('end', 'Deleted Contexts:\n' + str(self.delnodes)[1:-1])
        self.text.configure(state='normal')
        ###########deleted edges###############################
        self.edgescanvas = tk.Canvas(self.canvas, bg='white', bd=0, highlightthickness=0)
        self.edgescanvas.place(relx=0.75, rely=0.27, relwidth=0.35, relheight=0.2)
        self.text = tk.Text(self.edgescanvas, font=("Arial", 14), width=120, height=40)
        self.edgescanvas.create_window((0, 0), window=self.text, anchor='nw')
        self.text.insert('end', 'Deleted Edges:\n') #+ str(self.edges_del[1:-1]))
        self.text.configure(state='disabled')
        ##########radiobutton for edge delete node delete##########

        self.OptionList = [
            "Delete Node",
            "Delete Edge",
            "Get Metadata",
            "Combine Node",
            "Place Above Other Context",
            "Add Nodes",
            "Metadata Menu"
            ]
        self.variable = tk.StringVar(self.littlecanvas)
        self.variable.set("Node Action")
        self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)
        
        
        def destroy():
            self.testmenu.place_forget()
        #    # This is the function that removes the selected item when the label is clicked.
        def delete(*args):
           # print(self.variable.get())
            destroy()  
            self.testmenu.place_forget()
            self.variable.set("Node Action")
        
        
        def onRight(*args):
            self.littlecanvas.unbind("Button-1>")
            self.littlecanvas.bind("<Button-1>", onLeft)
            # Here we fetch our X and Y coordinates of the cursor RELATIVE to the window
            self.cursorx = int(self.littlecanvas.winfo_pointerx() - self.littlecanvas.winfo_rootx())
            self.cursory = int(self.littlecanvas.winfo_pointery() - self.littlecanvas.winfo_rooty())
        
            # Now we define our right click menu canvas
            # And here is where we use our X and Y variables, to place the menu where our cursor is,
            # That's how right click menus should be placed.           
            self.testmenu.place(x=self.cursorx, y=self.cursory)
            # This is for packing our options onto the canvas, to prevent the canvas from resizing.
            # This is extremely useful if you split your program into multiple canvases or frames
            # and the pack method is forcing them to resize.
            self.testmenu.pack_propagate(0)
            # Here is our label on the right click menu for deleting a row, notice the cursor
            # value, which will give us a pointy finger when you hover over the option.
            self.testmenu.config(width=10, bg="#b3dcf2", font=('Arial', 14))        
            # This function is for removing the canvas when an option is clicked.
  
        def preClick(*args):
            try:
                self.testmenu.place_forget()
                onRight()
            except Exception:
                onRight()
    
        # Hide menu when left clicking
        def onLeft(*args):
            try:
                self.testmenu.place_forget()
            except Exception:
                pass

        def open_file1(): 
            global node_df
            t0 = time.time()
            global FILE_INPUT
            file = askopenfile(mode ='r', filetypes =[('Python Files', '*.dot')])             
            FILE_INPUT = file.name
            self.graph = nx.DiGraph(imagefunc(file.name))
            if phase_true == 1:
                    self.image = imgrender_phase(self.graph)
            else:
                self.image = imgrender(self.graph)
            self.littlecanvas.img = ImageTk.PhotoImage(self.image)
            self.littlecanvas_img = self.littlecanvas.create_image(0, 0, anchor="nw",
                                                                   image=self.littlecanvas.img)

            self.width, self.height = self.image.size
            self.imscale = 1.0  # scale for the canvaas image
            self.delta = 1.1  # zoom magnitude
            # Put image into container rectangle and use it to set proper coordinates to the image
            self.container = self.littlecanvas.create_rectangle(0, 0, self.width, self.height, width=0)
            self.canvas.bind("<Configure>", self.resize)
            self.littlecanvas.bind("<Configure>", self.resize)
            self.nodescanvas.bind("<Configure>", self.resize)
            self.edgescanvas.bind("<Configure>", self.resize)
      #      node_df = node_coords_fromjson(self.graph)
     #      pos_dag = nx.drawing.nx_pydot.graphviz_layout(self.graph, prog='dot')
   #         node_df = pd.DataFrame.from_dict(pos_dag, orient='index')
       #     print(node_df)
            self.delnodes = []
            self.text.delete("1.0", "end")
            self.text = tk.Text(self.nodescanvas, font=("Arial", 14), width=120, height=40)
            self.nodescanvas.create_window((0, 0), window=self.text, anchor='nw')
            self.text.insert('end', 'Deleted Contexts:\n' + str(self.delnodes)[1:-1])
            self.text.configure(state='normal')
            self.testbutton = tk.Button(self.canvas, text ='Render Chronological DAG', command = lambda:popupWindow3(self, self.graph, self.littlecanvas2))
            self.testbutton.place(relx=0.61, rely=0.01, relwidth=0.2, relheight=0.03) 
        #    print((sys._getframe().f_code.co_name), str(time.time() - t0))
            #FILE_INPUT = fileFstt
                
        def open_file2(): 
            t0 = time.time()
            file = askopenfile(mode ='r', filetypes =[('Python Files', '*.csv')]) 
            if file is not None: 
                self.stratfile = pd.read_csv(file) 
               # return(content)
        
        def open_file3(): 
            t0 = time.time()
            file = askopenfile(mode ='r', filetypes =[('Python Files', '*.csv')]) 
            if file is not None: 
                self.datefile = pd.read_csv(file)
                for i, j in enumerate(self.datefile["context"]):
                   # print(self.graph.nodes()[str(j)])
                    #print(j, [self.datefile["date"][i], self.datefile["error"][i]])
                    self.graph.nodes()[str(j)].update({"Date":[self.datefile["date"][i], self.datefile["error"][i]]})
            #    print(self.datefile)
              #  return(content)
                
        def open_file4(): 
            t0 = time.time()
            file = askopenfile(mode ='r', filetypes =[('Python Files', '*.csv')]) 
            if file is not None: 
                self.phasefile = pd.read_csv(file) 
                for i, j in enumerate(self.phasefile["context"]):
                   # print(self.graph.nodes()[str(j)])
                    #print(j, [self.datefile["date"][i], self.datefile["error"][i]])
                    self.graph.nodes()[str(j)].update({"Phase":self.phasefile["phase"][i]})
         
              #  return(content) 
          #  print((sys._getframe().f_code.co_name), str(time.time() - t0))
#        self.b=tk.Button(self ,text="click me!", command=self.popup)
#        self.b.pack() 
        self.littlecanvas.bind("<Button-3>", preClick)
        #canvas to hold buttons
#        self.canvas1 = tk.Canvas(self.canvas, bg="white")
#        self.canvas1.place(relx=0.50, rely=0.35, relwidth=0.25, relheight=0.15)
        #canvas to hold metadata input
#        self.canvas2 = tk.Canvas(self.canvas, bg="white")
#        self.canvas2.place(relx=0.50, rely=0.5, relwidth=0.25, relheight=0.15)
#        #canvas to hold the metadata
        self.metacanvas = tk.Canvas(self.canvas, bg="white")
        self.metacanvas.place(relx=0.75, rely=0.52, relwidth=0.35, relheight=0.2)
        self.abovebelowcanvas = tk.Canvas(self.canvas, bg="white")
        self.abovebelowcanvas.place(relx=0.75, rely=0.75, relwidth=0.35, relheight=0.2)
#        #making node add section
#        #entry box for adding metadata
#        self.entry3 = tk.Entry(self.canvas)
#        self.button3 = tk.Button(text='Add Metadata to node', bg="#b3dcf2",
#                                 font=("Arial", 12), command=self.testcom)#need to add command
#        self.button4 = tk.Button(text='Phasing', bg="#b3dcf2",
#                                 font=("Arial", 12), command=self.phasing)
#        self.label3 = tk.Label(self.canvas, text='Node', bg='white', font=("Arial", 12))
#        self.canvas2.create_window(70, 45, window=self.entry3, width=50)
#        self.canvas2.create_window(70, 20, window=self.label3)
#        self.canvas2.create_window(140, 100, window=self.button3)
#        self.canvas2.create_window(300, 100, window=self.button4)
#        self.dict = {'Finds': ['Find1', 'Find2', 'Find3'],
#                     'Dates': ['Dates1', 'Dates2', 'Dates3'],
#                     'Phase': ['Phase1', 'Phase2', 'Phase3']}
#
#        self.variable_a = tk.StringVar(self.canvas2)
#        self.variable_b = tk.StringVar(self.canvas2)
#        self.variable_a.trace('w', self.update_options)
#        self.optionmenu_a = tk.OptionMenu(self.canvas2, self.variable_a, *self.dict.keys())
#        self.optionmenu_b = tk.OptionMenu(self.canvas2, self.variable_b, '')
#        self.variable_a.set('Finds')
#        self.optionmenu_a.place(relx=0.30, rely=0.25)
#        self.optionmenu_b.place(relx=0.550, rely=0.25)    
      
#    def popup(self):
#        self.w=popupWindow(self)
#      #  self.b["state"] = "disabled" 
#        self.wait_window(self.w.top)
#      #  self.b["state"] = "normal"
    def addedge(self, edgevec):
        global node_df
        x_1 = edgevec[0]
        x_2 = edgevec[1]
        self.graph.add_edge(x_1, x_2)
        if phase_true == 1:
            imgrender_phase(self.graph)
        else:
            imgrender(self.graph)
        self.image = Image.open('testdag.png')
        self.show_image()  

#    def full_chronograph_func(self):
#        #pt1
##        self.graphcopy = copy.deepcopy(self.graph)
##        step_1 = chrono_edge_remov(self.graphcopy)
##        graphedges = step_1[0][1][3]
##        #print(graphedges)        
##        graph = nx.DiGraph()
##        graph.add_edges_from(graphedges)
##        graph_new = nx.transitive_reduction(graph)
##        phases = list(graph_new.edges())
##        menu_list1 = []
##        menu_list_track = []
##        for i in phases:
##            menu_list1.append("Relationship between start of phase " + str(i[0]) + " and end of phase " + str(i[1]))
##            menu_list_track.append((str(i[0]), str(i[1])))
##        menu_list2 = ["abuting", "gap", "overlap"]
##        #pt2
##        
#        chrono_edge_add(self.graphcopy, self.step_1[0], self.step_1[1], self.menudict)
#        self.image2 = imgrender2(self.graphcopy)
#        self.littlecanvas2.img = ImageTk.PhotoImage(self.image2)
#        self.littlecanvas2_img = self.littlecanvas2.create_image(0, 0, anchor="nw",
#                                                               image=self.littlecanvas2.img)
#
#        self.width2, self.height2 = self.image2.size
#        self.imscale2 = 1.0  # scale for the canvaas image
#        self.delta2 = 1.1  # zoom magnitude
#        # Put image into container rectangle and use it to set proper coordinates to the image
#        self.container2 = self.littlecanvas2.create_rectangle(0, 0, self.width2, self.height2, width=0)
#        self.littlecanvas2.bind("<Configure>", self.resize2)         
        
    def stratfunc(self):
        rellist = list(nx.line_graph(self.graph))
        above = ()
        below = ()
        for i in enumerate(rellist):
            if str(self.entry3.get()) in rellist[i[0]]:
                if str(self.entry3.get()) == rellist[i[0]][0]:
                    below = np.append(below, rellist[i[0]][1])
                elif str(self.entry3.get()) == rellist[i[0]][1]:
                    above = np.append(above, rellist[i[0]][0])
        abovebelowtext = tk.Text(self.abovebelowcanvas, font=("Arial", 14),
                                 width=120, height=40)
        self.abovebelowcanvas.create_window((0, 0), window=abovebelowtext, anchor='nw')
        abovebelowtext.insert('end', 'Direct stratigraphic relationships:\n Contexts above: ' +
                              str(above) + '\n' + 'Contexts below:' + str(below))

    def nodecheck(self, x_current, y_current):
        t0 = time.time()
        """ returns the node that corresponds to the mouse cooridinates"""
        node_inside = "no node"
        node_df_con = node_coords_fromjson(self.graph)
        node_df = node_df_con[0]
        xmax, ymax = node_df_con[1]
        #forms a dataframe from the dicitonary of coords
#     #   givens upper and lower bounds for checking each node
#        x_lower = np.array(node_df[0]) - min(np.array(node_df[0])) - 0.5
#        x_upper = np.array(node_df[0]) + min(np.array(node_df[0])) - 0.5
#        y_lower = np.array(node_df[1]) - min(np.array(node_df[1])) - 0.5
#        y_upper = np.array(node_df[1]) + min(np.array(node_df[1])) - 0.5      
        x, y = self.image.size 
        cavx = x*self.imscale
        cany = y*self.imscale
#        node_df["x_lower"] = x_lower
#        node_df["x_upper"] = x_upper
#        node_df["y_lower"] = y_lower
#        node_df["y_upper"] = y_upper
 #       print(type(node_df))
        xscale = (x_current)*(xmax)/cavx
        yscale = (cany-y_current)*(ymax)/cany
       # print(xscale, yscale)
      #  print(xscale, yscale)
        for n_ind in range(node_df.shape[0]):
            if ((node_df.iloc[n_ind].x_lower < xscale < node_df.iloc[n_ind].x_upper) and
                    (node_df.iloc[n_ind].y_lower < yscale < node_df.iloc[n_ind].y_upper)):
                node_inside = node_df.iloc[n_ind].name       
#        print((sys._getframe().f_code.co_name), str(time.time() - t0))
        return node_inside

    def scroll_y(self, *args, **kwargs):
        t0 = time.time()
        """ Scroll canvas vertically and redraw the image"""
        self.canvas.yview(*args, **kwargs)  # scroll vertically
        
        self.show_image()
        print((sys._getframe().f_code.co_name), str(time.time() - t0))
        # redraw the image


    def scroll_x(self, *args, **kwargs):
        t0 = time.time()
        """Scroll canvas horizontally and redraw the image"""
        self.canvas.xview(*args, **kwargs)  # scroll horizontally
        self.show_image()  # redraw the image
#        print((sys._getframe().f_code.co_name), str(time.time() - t0))

    def edge_render(self):
        t0 = time.time()
        """renders string for deleted edges"""
        self.edges_del = self.edge_nodes
        edgetext = tk.Text(self.edgescanvas, font=("Arial", 14),
                           width=120, height=40)
        self.edgescanvas.create_window((0, 0), window=edgetext, anchor='nw')
        ednodes = str(self.edges_del[0]) + ' above '+ str(self.edges_del[1])
        self.temp = str(self.temp).replace('[', '')
        self.temp = str(self.temp).replace(']', '')
        self.temp = self.temp + '\n' + str(ednodes.replace("'", ""))
        edgetext.insert('end', 'Deleted Edges:' + str(self.temp))
        edgetext.configure()
       # self.edge_nodes = []
#        print((sys._getframe().f_code.co_name), str(time.time() - t0))
#

    def nodes(self, currentevent):
        """deletes the node and redraws the graph"""
        t0 = time.time()
        self.testmenu.place_forget()
        if self.image != "noimage":
            x_scal = self.cursorx + self.transx
            y_scal = self.cursory + self.transy
            node = self.nodecheck(x_scal, y_scal)
            if self.variable.get() == "Delete Node":
                if node != "no node":
                    self.graph.remove_node(node)
                    self.delnodes = np.append(self.delnodes, node)
            
            if self.variable.get() == "Add Nodes":
                self.w=popupWindow(self)
      #  self.b["state"] = "disabled" 
                self.wait_window(self.w.top)
                node = self.w.value 
                print(node)
                self.graph.add_node(node, shape="box", fontsize="30.0",
                                   fontname="Arial", penwidth="1.0")                   
                           
            if self.variable.get() == "Metadata Menu":
                self.w=popupWindow2(self, self.graph, self.metacanvas)    
            if len(self.edge_nodes) == 1:       
                if self.variable.get() == "Delete Edge with "+ str(self.edge_nodes[0]):
                    self.edge_nodes = np.append(self.edge_nodes, node)
               #     print(self.edge_nodes)
                    try:
                        self.graph.remove_edge(self.edge_nodes[0], self.edge_nodes[1])
                        self.edge_render()
                    except (KeyError, nx.exception.NetworkXError):
                        try:
                            self.graph.remove_edge(self.edge_nodes[1], self.edge_nodes[0])
                            self.edge_render()
                        except (KeyError, nx.exception.NetworkXError):
                            tk.messagebox.showinfo('Error', 'An edge doesnt exist between those nodes')
                    
                    self.OptionList.remove("Delete Edge with "+ str(self.edge_nodes[0]))
                    self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command=self.nodes)
                    self.edge_nodes = []

                if self.variable.get() == ("Place "+ str(self.edge_nodes[0]) + " Above"):
                    self.edge_nodes = np.append(self.edge_nodes, node)
               #     print(self.edge_nodes)
    
                    self.addedge(self.edge_nodes)
                    self.OptionList.remove("Place "+ str(self.edge_nodes[0]) + " Above")
                    self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command=self.nodes)
                    self.edge_nodes = []      
                    
            if self.variable.get() == "Delete Edge":
          #      print("test1")
                if len(self.edge_nodes) == 1:
                    self.OptionList.remove("Delete Edge with "+ str(self.edge_nodes[0]))
                    self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)
                    self.edge_nodes = []                    
                self.edge_nodes = np.append(self.edge_nodes, node)                
                self.OptionList.append("Delete Edge with "+ str(self.edge_nodes[0]))
                self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)

            if len(self.comb_nodes) == 1:       
                if self.variable.get() == "Combine Node with "+ str(self.comb_nodes[0]):
                    self.comb_nodes = np.append(self.comb_nodes, node)
                    self.graph = nx.contracted_nodes(self.graph, self.comb_nodes[0], self.comb_nodes[1])
                    x_nod = list(self.graph) 
                    newnode = str(self.comb_nodes[0]) + " = " + str(self.comb_nodes[1])
                    y_nod = [newnode if i==self.comb_nodes[0] else i for i in x_nod]
            #        print(y_nod)
                    mapping = dict(zip(x_nod, y_nod))
                    self.graph = nx.relabel_nodes(self.graph, mapping)
              #      print(list(self.graph))
                    self.OptionList.remove("Combine Node with "+ str(self.comb_nodes[0]))
                    self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)
                    self.comb_nodes = []
                    
            if self.variable.get() == "Combine Node":
                if len(self.comb_nodes) == 1:
                    self.OptionList.remove("Combine Node with "+ str(self.comb_nodes[0]))
                    self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)
                    self.comb_nodes = []                    
                self.comb_nodes = np.append(self.comb_nodes, node)                
                self.OptionList.append("Combine Node with "+ str(self.comb_nodes[0]))
                self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)       
                            
            if self.variable.get() == "Get Metadata":
                self.metatext = tk.Text(self.metacanvas, font=("Arial", 14), width=120, height=40)
                self.metacanvas.create_window((0, 0), window=self.metatext, anchor='nw')
                self.meta1 = pd.DataFrame.from_dict(self.graph.nodes()[str(node)], orient='index')
                self.meta2 = self.meta1.loc["Date":"Phase",]
                self.meta2.columns = ["Data"]
                #if self.meta2.loc["Date"] != "None":
                if self.meta2.loc["Date"][0] != "None":
                   self.meta2.loc["Date"][0] = str(self.meta2.loc["Date"][0][0]) + " +- " + str(self.meta2.loc["Date"][0][1]) + " Carbon BP"
               # self.nice_meta2 = tabulate(self.meta2, headers='keys', tablefmt='psql')
                self.metatext.insert('end', 'Metadata of node ' +
                                     str(node) + ':\n')
                cols = list(self.meta2.columns)
                tree = ttk.Treeview(self.metacanvas)
                tree["columns"] = cols
                tree.place(relx=0, rely=0.25)
                tree.column("Data", anchor="w")
                tree.heading("Data", text="Data", anchor='w')        
                for index, row in self.meta2.iterrows():
                    tree.insert("",0,text=index,values=list(row))
                self.metatext.configure()
                    
            if self.variable.get() == "Place Above Other Context":
          #      print("test1")
                if len(self.edge_nodes) == 1:
                    "tester"
                    self.OptionList.remove("Place "+ str(self.edge_nodes[0]) + " Above")
                    self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)
                    self.edge_nodes = []                    
                self.edge_nodes = np.append(self.edge_nodes, node)                
                self.OptionList.append("Place "+ str(self.edge_nodes[0]) + " Above")
                self.testmenu = tk.OptionMenu(self.littlecanvas, self.variable, *self.OptionList, command = self.nodes)
                
            if phase_true == 1:
                imgrender_phase(self.graph)
            else:
                imgrender(self.graph)
            print("halfway", time.time()-t0) 
            self.image = Image.open('testdag.png')
            self.width, self.height = self.image.size
            self.container = self.littlecanvas.create_rectangle(0, 0, self.width, self.height, width=0)
            self.show_image()
            self.text = tk.Text(self.nodescanvas, font=("Arial", 14), width=120, height=40)
            self.nodescanvas.create_window((0, 0), window=self.text, anchor='nw')
            nbnodes = str(self.delnodes)
            self.text.insert('end', 'Deleted Contexts:\n' + str(nbnodes.replace("'", ""))[1:-1])
            self.text.configure(state='normal')
            self.variable.set("Node Action")
            self.littlecanvas.unbind('<Button-1>')
            self.littlecanvas.bind('<Button-1>', self.move_from)
            self.littlecanvas.bind("<MouseWheel>", self.wheel)
     #       print(time.time() - t0)
           # self.pos_update()
      #      background(print_numbers(50))
          #  self.text.after(10000, print("hi"))
        #    print(time.time() - t0)
        print((sys._getframe().f_code.co_name), str(time.time() - t0)) 

    def pos_update(self):
        t0 = time.time()
        global node_df
        #if phase_true == 1:
           # pos_dag = node_coords_fromjson(self.graph)
        #else: 
          #  pos_dag = nx.drawing.nx_pydot.graphviz_layout(self.graph, prog='dot')
        node_df = node_coords_fromjson(self.graph) 
      #  print("tester")
    #    print((sys._getframe().f_code.co_name), str(time.time() - t0))


    def move_from(self, event):
        t0 = time.time()
        """Remembers previous coordinates for scrolling with the mouse"""
        if self.image != "noimage":
            self.littlecanvas.scan_mark(event.x, event.y)
  #      print((sys._getframe().f_code.co_name), str(time.time() - t0))

    def move_to(self, event):
        t0 = time.time()
        """Drag (move) canvas to the new position"""
        if self.image != "noimage":
            self.littlecanvas.scan_dragto(event.x, event.y, gain=1)
            self.show_image()
            bbox = self.littlecanvas.bbox(self.container)
        # redraw the image

    def wheel(self, event):
        t0 = time.time()
        """Zoom with mouse wheel"""
        x_zoom = self.littlecanvas.canvasx(event.x)
        y_zoom = self.littlecanvas.canvasy(event.y)
        bbox = self.littlecanvas.bbox(self.container)  # get image area 
        if bbox[0] < x_zoom < bbox[2] and bbox[1] < y_zoom < bbox[3]:
            pass  # Ok! Inside the image
        else: return  # zoom only inside image area
        scale = 1.0
        # Respond to Linux (event.num) or Windows (event.delta) wheel event
        if event.num == 5 or event.delta == -120:  # scroll down
            i = min(self.width, self.height)
            if int(i * self.imscale) < 30:
                return  # image is less than 30 pixels
            self.imscale /= self.delta
            scale /= self.delta
        if event.num == 4 or event.delta == 120:  # scroll up
            i = min(self.littlecanvas.winfo_width(), self.littlecanvas.winfo_height())
            if i < self.imscale:
                return  # 1 pixel is bigger than the visible area
            self.imscale *= self.delta
            scale *= self.delta  
        self.littlecanvas.scale('all', 0, 0, scale, scale)  # rescale all canvas objects
        self.show_image()
#        print((sys._getframe().f_code.co_name), str(time.time() - t0))
    def wheel2(self, event):
        t0 = time.time()
        """Zoom with mouse wheel"""
        x_zoom = self.littlecanvas2.canvasx(event.x)
        y_zoom = self.littlecanvas2.canvasy(event.y)
        bbox = self.littlecanvas2.bbox(self.container2)  # get image area 
        if bbox[0] < x_zoom < bbox[2] and bbox[1] < y_zoom < bbox[3]:
            pass  # Ok! Inside the image
        else: return  # zoom only inside image area
        scale2 = 1.0
        # Respond to Linux (event.num) or Windows (event.delta) wheel event
        if event.num == 5 or event.delta == -120:  # scroll down
            i = min(self.width2, self.height2)
            if int(i * self.imscale2) < 30:
                return  # image is less than 30 pixels
            self.imscale2 /= self.delta2
            scale2 /= self.delta2
        if event.num == 4 or event.delta == 120:  # scroll up
            i = min(self.littlecanvas2.winfo_width(), self.littlecanvas2.winfo_height())
            if i < self.imscale2:
                return  # 1 pixel is bigger than the visible area
            self.imscale2 *= self.delta2
            scale2 *= self.delta2  
        self.littlecanvas2.scale('all', 0, 0, scale2, scale2)  # rescale all canvas objects
        self.show_image2()

    def show_image(self):
        """Show image on the Canvas"""
        bbox1 = [0, 0, int(self.image.size[0]*self.imscale), int(self.image.size[1]*self.imscale)]
        # Remove 1 pixel shift at the sides of the bbox1
        bbox1 = (bbox1[0] + 1, bbox1[1] + 1, bbox1[2] - 1, bbox1[3] - 1)
        bbox2 = (self.littlecanvas.canvasx(0),  # get visible area of the canvas
                 self.littlecanvas.canvasy(0),
                 self.littlecanvas.canvasx(self.littlecanvas.winfo_width()),
                 self.littlecanvas.canvasy(self.littlecanvas.winfo_height()))
        bbox = [min(bbox1[0], bbox2[0]), min(bbox1[1], bbox2[1]),  # get scroll region box
                max(bbox1[2], bbox2[2]), max(bbox1[3], bbox2[3])]
        bbox1 = [0, 0, int(self.image.size[0]*self.imscale), int(self.image.size[1]*self.imscale)]
        if bbox[0] == bbox2[0] and bbox[2] == bbox2[2]:  # whole image in the visible area
            bbox[0] = bbox1[0]
            bbox[2] = bbox1[2]
        if bbox[1] == bbox2[1] and bbox[3] == bbox2[3]:  # whole image in the visible area
            bbox[1] = bbox1[1]
            bbox[3] = bbox1[3]
        self.littlecanvas.configure(scrollregion=bbox)  # set scroll region
        x_1 = max(bbox2[0] - bbox1[0], 0)  # get coordinates (x1,y1,x2,y2) of the image tile
        y_1 = max(bbox2[1] - bbox1[1], 0)
        x_2 = min(bbox2[2], bbox1[2]) - bbox1[0]
        y_2 = min(bbox2[3], bbox1[3]) - bbox1[1]
        if int(x_2 - x_1) > 0 and int(y_2 - y_1) > 0:  # show image if it in the visible area
            x_img = min(int(x_2 / self.imscale), self.width)   # sometimes it is larger on 1 pixel
            y_img = min(int(y_2 / self.imscale), self.height)  # ...and sometimes not
            image = self.image.crop((int(x_1 / self.imscale), int(y_1 / self.imscale),
                                     x_img, y_img))
            self.imagetk = ImageTk.PhotoImage(image.resize((int(x_2 - x_1), int(y_2 - y_1))))
            self.littlecanvas.delete(self.littlecanvas_img)
            self.imageid = self.littlecanvas.create_image(max(bbox2[0], bbox1[0]),
                                                          max(bbox2[1], bbox1[1]), anchor='nw',
                                                          image=self.imagetk)
            self.transx, self.transy = bbox2[0], bbox2[1]
            self.littlecanvas.imagetk = self.imagetk
            
    def show_image2(self):
        """Show image on the Canvas"""
        bbox1 = [0, 0, int(self.image2.size[0]*self.imscale2), int(self.image2.size[1]*self.imscale2)]
        # Remove 1 pixel shift at the sides of the bbox1
        bbox1 = (bbox1[0] + 1, bbox1[1] + 1, bbox1[2] - 1, bbox1[3] - 1)
        bbox2 = (self.littlecanvas2.canvasx(0),  # get visible area of the canvas
                 self.littlecanvas2.canvasy(0),
                 self.littlecanvas2.canvasx(self.littlecanvas2.winfo_width()),
                 self.littlecanvas2.canvasy(self.littlecanvas2.winfo_height()))
        bbox = [min(bbox1[0], bbox2[0]), min(bbox1[1], bbox2[1]),  # get scroll region box
                max(bbox1[2], bbox2[2]), max(bbox1[3], bbox2[3])]
        bbox1 = [0, 0, int(self.image2.size[0]*self.imscale2), int(self.image2.size[1]*self.imscale2)]
        if bbox[0] == bbox2[0] and bbox[2] == bbox2[2]:  # whole image in the visible area
            bbox[0] = bbox1[0]
            bbox[2] = bbox1[2]
        if bbox[1] == bbox2[1] and bbox[3] == bbox2[3]:  # whole image in the visible area
            bbox[1] = bbox1[1]
            bbox[3] = bbox1[3]
        self.littlecanvas2.configure(scrollregion=bbox)  # set scroll region
        x_1 = max(bbox2[0] - bbox1[0], 0)  # get coordinates (x1,y1,x2,y2) of the image tile
        y_1 = max(bbox2[1] - bbox1[1], 0)
        x_2 = min(bbox2[2], bbox1[2]) - bbox1[0]
        y_2 = min(bbox2[3], bbox1[3]) - bbox1[1]
        if int(x_2 - x_1) > 0 and int(y_2 - y_1) > 0:  # show image if it in the visible area
            x_img = min(int(x_2 / self.imscale2), self.width2)   # sometimes it is larger on 1 pixel
            y_img = min(int(y_2 / self.imscale2), self.height2)  # ...and sometimes not
            image2 = self.image2.crop((int(x_1 / self.imscale2), int(y_1 / self.imscale2),
                                     x_img, y_img))
            self.imagetk2 = ImageTk.PhotoImage(image2.resize((int(x_2 - x_1), int(y_2 - y_1))))
            self.littlecanvas2.delete(self.littlecanvas2_img)
            self.imageid2 = self.littlecanvas2.create_image(max(bbox2[0], bbox1[0]),
                                                          max(bbox2[1], bbox1[1]), anchor='nw',
                                                          image=self.imagetk2)
            self.transx2, self.transy2 = bbox2[0], bbox2[1]
            self.littlecanvas.imagetk2 = self.imagetk2            


    def phasing(self):
        global phase_true, node_df
        t0 = time.time()
        """runs image render function with phases on seperate levels"""
        imgrender_phase(self.graph)
        self.image = Image.open('testdag.png')
        phase_true = 1
        self.show_image()
        node_df = node_coords_fromjson("fi_new.txt")
    #    node_df = pd.DataFrame.from_dict(pos_dag, orient='index')
 #       print((sys._getframe().f_code.co_name), str(time.time() - t0))
        return node_df


    def resize(self, event):
        t0 = time.time()
        """resizes image on canvas"""
        img = Image.open('testdag.png')#.resize((event.width, event.height), Image.ANTIALIAS)
        self.littlecanvas.img = ImageTk.PhotoImage(img)
        self.w_1 = event.width
        self.h_1 = event.height
        self.littlecanvas.itemconfig(self.littlecanvas_img, image=self.littlecanvas.img)
        
    def resize2(self, event):
        t0 = time.time()
        """resizes image on canvas"""
        img = Image.open('testdag.png')#.resize((event.width, event.height), Image.ANTIALIAS)
        self.littlecanvas2.img = ImageTk.PhotoImage(img)
        self.w_1 = event.width
        self.h_1 = event.height
        self.littlecanvas2.itemconfig(self.littlecanvas2_img, image=self.littlecanvas2.img)        
   #     print((sys._getframe().f_code.co_name), str(time.time() - t0))

MAIN_FRAME = MainFrame()
MAIN_FRAME.geometry("2000x1000")
MAIN_FRAME.mainloop()
 